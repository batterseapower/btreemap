// Quick guide to making a release:
// $ git tag vX.Y.Z
// $ gradle bintrayUpload
//
// Please choose a version number using the principles of semantic versioning (http://semver.org):
//  - MAJOR version when you make incompatible API changes,
//  - MINOR version when you add functionality in a backwards-compatible manner, and
//  - PATCH version when you make backwards-compatible bug fixes.

buildscript {
    repositories {
        jcenter()
        maven { url "http://dl.bintray.com/palantir/releases" }
    }
    dependencies {
        classpath 'com.bmuschko:gradle-nexus-plugin:2.3.1'
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
        classpath 'com.palantir:gradle-gitsemver:0.7.1'
        classpath 'org.jtwig:jtwig-core:5.65'
    }
}

apply plugin: 'java'

// Lets us sign our artifacts, construct a POM and use the uploadArchives task to upload to Sonatype OSS
// The disadvantage of going this route is that anything we upload to Sonatype has to be
// manually "closed" in the web interface (Nexus: https://oss.sonatype.org/) before it
// shows up on Maven Central.
apply plugin: 'com.bmuschko.nexus'

// So we augment Nexus with this plugin, which lets us upload the signed, POMified artifacts
// to Bintray. Bintray operate a Maven repo called JCenter which can be used as an alternative
// to Maven Central, but which also supports fully automatic syncing to Maven Central via Sonatype OSS.
// So this plugin lets us upload to Bintray + JCenter + Maven Central with a single "bintrayUpload" task
apply plugin: 'com.jfrog.bintray'

apply plugin: 'gitsemver'

// The Palantir plugin infers the version number from the git tags: https://github.com/palantir/gradle-gitsemver
// When you update the version number, please follow the principles of Semantic Versioning: http://semver.org
version semverVersion()
group 'uk.co.omega-prime'

def projectName = 'btreemap'
def projectDescription = 'A simple and high-performance Java B-tree: drop-in replacement for java.util.TreeMap.'

sourceCompatibility = 1.8

import org.jtwig.environment.EnvironmentConfiguration
import org.jtwig.environment.DefaultEnvironmentConfiguration
import org.jtwig.JtwigTemplate
import org.jtwig.JtwigModel

class TypeProperties {
    private final String name, primitive, boxed, erased, erasedBoxed, dfault;
    
    private TypeProperties(String name, String primitive, String boxed, String erased, String erasedBoxed, String dfault) {
        this.name = name
        this.primitive = primitive;
        this.boxed = boxed;
        this.erased = erased;
        this.erasedBoxed = erasedBoxed;
        this.dfault = dfault;
    }
    
    String getName() { return name; }
    String getPrimitive() { return primitive; }
    String getBoxed() { return boxed; }
    String getUnboxed() { return primitive == null ? boxed : primitive; }
    String getErased() { return erased; }
    String getErasedBoxed() { return erasedBoxed; }
    String getDfault() { return dfault; }

    boolean isPrimitive() { return primitive != null; }
    boolean isObject()    { return !isPrimitive(); }

    String toString() { return primitive; }

    static final TypeProperties INT  = new TypeProperties("Int",  "int",  "Integer", "int",  "Integer", "Integer.MIN_VALUE")
    static final TypeProperties LONG = new TypeProperties("Long", "long", "Long",    "long", "Long",    "Long.MIN_VALUE")

    static TypeProperties object(String tyParam) {
        return new TypeProperties("Object", null, tyParam, "Object", "Object", "null");
    }
    
    static final List<TypeProperties> PRIMITIVE = [INT, LONG]
}

abstract class TypesProperties {
    final JtwigModel model;

    TypesProperties(JtwigModel model) {
        this.model = model
    }

    // We have a few hacky extensions to the template language to let us write the templates without
    // *totally* breaking intellij. We apply those in this method.
    abstract String tweakTemplate(String line);
}

// There's no two ways about it: this is extremely ugly. But it does get the job done, and it doesn't impact library users.
task generateJava {
    doLast{
        delete fileTree(dir: "${buildDir}/generated-src")

        EnvironmentConfiguration configuration = new DefaultEnvironmentConfiguration()

        FileTree tree = fileTree(dir: 'src/main/templates', include: '**/*.java')
        tree.each { File input ->
            String relative = file('src/main/templates').toPath().relativize(input.getParentFile().toPath()).toString()

            List<TypesProperties> types = []
            if (input.getName().contains('{{KV_}}')) {
                for (k in [TypeProperties.object("K")] + TypeProperties.PRIMITIVE) {
                    for (v in [TypeProperties.object("V")] + TypeProperties.PRIMITIVE) {
                        String kPrefix, kvPrefix, kObjectPrefix, kTyReplacement, kvTyReplacement, kvComparableTyReplacement,
                               kObjectTyReplacement, kvsupTyReplacement, ksupvTyReplacement, ksupTyReplacement, ksupvsupTyReplacement
                        if (k.isObject() && v.isObject()) {
                            kPrefix = ''
                            kvPrefix = ''
                            kObjectPrefix = ''
                            kTyReplacement = '<K>'
                            ksupTyReplacement = '<? super K>'
                            kvTyReplacement = '<K,V>'
                            kvComparableTyReplacement = '<K extends Comparable<? super K>, V>'
                            kObjectTyReplacement = '<K, AbstractNode>'
                            kvsupTyReplacement = '<?, ? super V>'
                            ksupvTyReplacement = '<? super K, ?>'
                            ksupvsupTyReplacement = '<? super K, ? super V>'
                        } else if (k.isObject()) {
                            kPrefix = ''
                            kvPrefix = 'Object' + v.name
                            kObjectPrefix = ''
                            kTyReplacement = '<K>'
                            ksupTyReplacement = '<? super K>'
                            kvTyReplacement = '<K>'
                            kvComparableTyReplacement = '<K extends Comparable<? super K>>'
                            kObjectTyReplacement = '<K, AbstractNode>'
                            kvsupTyReplacement = '<?>'
                            ksupvTyReplacement = '<? super K>'
                            ksupvsupTyReplacement = '<? super K>'
                        } else if (v.isObject()) {
                            kPrefix = k.name
                            kvPrefix = k.name + 'Object'
                            kObjectPrefix = k.name + 'Object'
                            kTyReplacement = ''
                            ksupTyReplacement = ''
                            kvTyReplacement = kvComparableTyReplacement = '<V>'
                            kObjectTyReplacement = '<Object>'
                            kvsupTyReplacement = '<? super V>'
                            ksupvTyReplacement = '<?>'
                            ksupvsupTyReplacement = '<? super V>'
                        } else {
                            kPrefix = k.name
                            kvPrefix = k.name + v.name
                            kObjectPrefix = k.name + 'Object'
                            kTyReplacement = ''
                            ksupTyReplacement = ''
                            kvTyReplacement = kvComparableTyReplacement = ''
                            kObjectTyReplacement = ''
                            kvsupTyReplacement = ''
                            ksupvTyReplacement = ''
                            ksupvsupTyReplacement = ''
                        }

                        types.add(new TypesProperties(JtwigModel.newModel()
                                .with("K", k).with("V", v)
                                .with("K_", k.isObject() ? "" : k.name)
                                .with("KV_", kvPrefix)
                                .with("KObject_", kObjectPrefix)) {
                            String tweakTemplate(String line) {
                                return line.replaceAll('([A-Za-z]+)<[$]K[$], ?[$]V[$]>[.]class', kvPrefix + '$1.class')
                                        .replaceAll('([A-Za-z]+)<[$]K[$], ?[$]V[$]>', kvPrefix + '$1' + kvTyReplacement)
                                        .replaceAll('([A-Za-z]+)<[$]K[$], ?AbstractNode>', kObjectPrefix + '$1' + kObjectTyReplacement)
                                        .replaceAll('<[$]K[$] extends Comparable<[?] super [$]K[$]>, [$]V[$]>', kvComparableTyReplacement)
                                        .replaceAll('([A-Za-z]+)<[?], ?[?] super [$]V[$]>', kvPrefix + '$1' + kvsupTyReplacement)
                                        .replaceAll('([A-Za-z]+)<[?] super [$]K[$], ?[?]>', kvPrefix + '$1' + ksupvTyReplacement)
                                        .replaceAll('([A-Za-z]+)<[?] super [$]K[$], ?[?] super [$]V[$]>', kvPrefix + '$1' + ksupvsupTyReplacement)
                                        .replaceAll('([A-Za-z]+)<[?] super (@Boxed )?[$]K[$]>', kPrefix + '$1' + ksupTyReplacement)
                                        .replaceAll('<[$]K[$], ?[$]V[$]>', kvTyReplacement)
                                        .replaceAll('([A-Za-z]+)<[$]K[$]>', kPrefix + '$1' + kTyReplacement)
                                        .replaceAll('<[$]K[$]>', kTyReplacement)
                                        .replaceAll('([A-Za-z]+)<[$]K[$]>', '{{K_}}$1')
                                        .replace('@Erased @Boxed $V$', '{{V.erasedBoxed}}')
                                        .replace('@Erased $K$', '{{K.erased}}')
                                        .replace('@Erased $V$', '{{V.erased}}')
                                        .replace('@Boxed $K$', '{{K.boxed}}')
                                        .replace('@Boxed $V$', '{{V.boxed}}')
                                        .replace('$K$', '{{K.unboxed}}')
                                        .replace('$V$', '{{V.unboxed}}')
                            }
                        })
                    }
                }
            } else if (input.getName().contains('{{K_}}')) {
                for (k in [TypeProperties.object("K")] + TypeProperties.PRIMITIVE) {
                    if (k.isObject() && input.getName().equals("{{K_}}Comparator.java")) {
                        // Hack because the JDK already has a boxed comparator
                        continue
                    }

                    types.add(new TypesProperties(JtwigModel.newModel()
                            .with("K", k)
                            .with("K_", k.isObject() ? "" : k.name)) {
                        @Override
                        String tweakTemplate(String line) {
                            return line.replaceAll('([A-Za-z]+)<[$]K[$]>', '{{K_}}$1')
                                    .replace('$K$', '{{K.unboxed}}')
                        }
                    })
                }
            } else {
                throw new IllegalStateException("Found template ${input} that didn't have any obvious filename pattern")
            }

            for (TypesProperties type : types) {
                JtwigTemplate filenameTemplate = JtwigTemplate.inlineTemplate(input.getName(), configuration)
                String outputFilename = filenameTemplate.render(type.model)

                List<String> inputLines = input.readLines("UTF-8").collect { type.tweakTemplate(it) }
                JtwigTemplate fileTemplate = JtwigTemplate.inlineTemplate(inputLines.join("\n"), configuration)
                String output = fileTemplate.render(type.model)

                File outputFile = new File(file("${buildDir}/generated-src/${relative}"), outputFilename)
                outputFile.getParentFile().mkdirs()

                if (!java.nio.file.Files.notExists(outputFile.toPath())) {
                    throw new IOException("Can't write to ${outputFile} twice")
                }

                outputFile.write(output)
            }
        }

    }
}

apply plugin: "idea"
sourceSets.main.java.srcDir new File("${buildDir}/generated-src")
idea {
    module {
        generatedSourceDirs += file("${buildDir}/generated-src")
    }
}

compileJava {
    dependsOn generateJava
    source "${buildDir}/generated-src"
}

javadoc {
    dependsOn generateJava
    source "${buildDir}/generated-src"
}

jar {
    baseName = projectName
    manifest {
        attributes 'Implementation-Title': projectName,
                   'Implementation-Version': version
    }
}

repositories {
    mavenCentral()
}

dependencies {
    compile group: 'com.google.code.findbugs', name: 'jsr305', version: '3.0.1'
    testCompile group: 'junit', name: 'junit', version: '4.12'
    testCompile group: 'com.pholser', name: 'junit-quickcheck-core', version: '0.7'
    testCompile group: 'com.pholser', name: 'junit-quickcheck-generators', version: '0.7'
    testCompile group: 'org.openjdk.jmh', name: 'jmh-generator-annprocess', version: '1.17.3'

    //testCompile group: 'it.unimi.dsi', name: 'fastutil', version: '7.0.13'
    //testCompile group: 'org.mapdb', name: 'mapdb', version: '1.0.9'
}

task benchmark(type: JavaExec) {
    classpath sourceSets.test.runtimeClasspath
    main = "uk.co.omegaprime.btreemap.BTreeMapBenchmark"
    args "-f1"
}

// I don't like writing JavaDoc for every param individually.
// http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html
if (JavaVersion.current().isJava8Compatible()) {
    allprojects {
        tasks.withType(Javadoc) {
            // The -quiet is because of some sort of weird JDK JavaCompiler bug: https://discuss.gradle.org/t/passing-arguments-to-compiler-and-javadoc/1661
            options.addStringOption('Xdoclint:all,-missing', '-quiet')
        }
    }
}
// Used by the nexus plugin
modifyPom {
    project {
        name projectName
        description projectDescription
        url 'https://github.com/batterseapower/btreemap'

        scm {
            url 'https://github.com/batterseapower/btreemap'
            connection 'scm:https://batterseapower@github.com/batterseapower/btreemap.git'
            developerConnection 'scm:git://github.com/batterseapower/btreemap.git'
        }

        licenses {
            license {
                name 'The Apache Software License, Version 2.0'
                url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                distribution 'repo'
            }
        }

        developers {
            developer {
                id 'batterseapower'
                name 'Max Bolingbroke'
                email 'batterseapower@hotmail.com'
            }
        }
    }
}

// I tried to have the Nexus plugin sign things, rather than using the Bintray
// automatic signing support, but when e.g. mdbi-1.0.2-sources.jar.asc got uploaded
// to Bintray, Bintray seemed to mangle the filename to mdbi-1.0.2-sources-jar.asc.
// This would obviously cause the Maven Central publish to fail because it couldn't
// figure out what file that was meant to be a signature for. So I gave up, gave
// Bintray my GPG private key, and turned on auto-signing in the BinTray repo settings.
nexus {
    sign = false
}

// e.g. Travis won't have the Bintray config
if (hasProperty('bintrayUsername') || System.getenv().containsKey('BINTRAY_USER')) {
    // Used by the bintray plugin
    bintray {
        user = System.getenv().getOrDefault('BINTRAY_USER', bintrayUsername)
        key  = System.getenv().getOrDefault('BINTRAY_KEY', bintrayApiKey)
        publish = true

        pkg {
            repo = 'maven'
            name = projectName                                    
            licenses = ['Apache-2.0']
            vcsUrl = 'https://github.com/batterseapower/btreemap.git'

            version {
                name = project.version
                desc = projectDescription
                released = new Date()

                mavenCentralSync {
                    user     = System.getenv().getOrDefault('SONATYPE_USER', nexusUsername)
                    password = System.getenv().getOrDefault('SONATYPE_PASSWORD', nexusPassword)
                }
            }
        }

        configurations = ['archives']
    }
}
